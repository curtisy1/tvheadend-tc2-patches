--- linux/drivers/media/usb/dvb-usb-v2/af9035.c	2020-01-10 06:40:19.000000000 +0100
+++ af9035.c	2020-01-25 22:24:28.896291738 +0100
@@ -1,9 +1,22 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Afatech AF9035 DVB USB driver
  *
  * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
  * Copyright (C) 2012 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include "af9035.h"
@@ -107,6 +120,8 @@
 		memcpy(req->rbuf, &state->buf[ACK_HDR_LEN], req->rlen);
 exit:
 	mutex_unlock(&d->usb_mutex);
+	if (ret < 0)
+		dev_dbg(&intf->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -189,7 +204,7 @@
 		.platform_data = platform_data,
 	};
 
-	strscpy(board_info.type, type, I2C_NAME_SIZE);
+	strlcpy(board_info.type, type, I2C_NAME_SIZE);
 
 	/* find first free client */
 	for (num = 0; num < AF9035_I2C_CLIENT_MAX; num++) {
@@ -208,8 +223,8 @@
 	request_module("%s", board_info.type);
 
 	/* register I2C device */
-	client = i2c_new_client_device(adapter, &board_info);
-	if (!i2c_client_has_driver(client)) {
+	client = i2c_new_device(adapter, &board_info);
+	if (client == NULL || client->dev.driver == NULL) {
 		ret = -ENODEV;
 		goto err;
 	}
@@ -387,10 +402,8 @@
 			if (msg[0].addr == state->af9033_i2c_addr[1])
 				reg |= 0x100000;
 
-			ret = (msg[0].len >= 3) ? af9035_wr_regs(d, reg,
-							         &msg[0].buf[3],
-							         msg[0].len - 3)
-					        : -EOPNOTSUPP;
+			ret = af9035_wr_regs(d, reg, &msg[0].buf[3],
+					msg[0].len - 3);
 		} else {
 			/* I2C write */
 			u8 buf[MAX_XFER_SIZE];
@@ -831,7 +844,6 @@
 	state->af9033_config[1].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;
 	state->af9033_config[0].ts_mode = AF9033_TS_MODE_USB;
 	state->af9033_config[1].ts_mode = AF9033_TS_MODE_SERIAL;
-	state->it930x_addresses = 0;
 
 	if (state->chip_type == 0x9135) {
 		/* feed clock for integrated RF tuner */
@@ -858,10 +870,6 @@
 		 * IT930x is an USB bridge, only single demod-single tuner
 		 * configurations seen so far.
 		 */
-		if ((le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA) &&
-		    (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_TD310)) {
-			state->it930x_addresses = 1;
-		}
 		return 0;
 	}
 
@@ -1197,15 +1205,6 @@
 	return ret;
 }
 
-/*
- * The I2C speed register is calculated with:
- *	I2C speed register = (1000000000 / (24.4 * 16 * I2C_speed))
- *
- * The default speed register for it930x is 7, with means a
- * speed of ~366 kbps
- */
-#define I2C_SPEED_366K 7
-
 static int it930x_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	struct state *state = adap_to_priv(adap);
@@ -1215,15 +1214,15 @@
 	struct si2168_config si2168_config;
 	struct i2c_adapter *adapter;
 
-	dev_dbg(&intf->dev, "adap->id=%d\n", adap->id);
+	dev_dbg(&intf->dev, "%s  adap->id=%d\n", __func__, adap->id);
 
-	/* I2C master bus 2 clock speed 366k */
-	ret = af9035_wr_reg(d, 0x00f6a7, I2C_SPEED_366K);
+	/* I2C master bus 2 clock speed 300k */
+	ret = af9035_wr_reg(d, 0x00f6a7, 0x07);
 	if (ret < 0)
 		goto err;
 
-	/* I2C master bus 1,3 clock speed 366k */
-	ret = af9035_wr_reg(d, 0x00f103, I2C_SPEED_366K);
+	/* I2C master bus 1,3 clock speed 300k */
+	ret = af9035_wr_reg(d, 0x00f103, 0x07);
 	if (ret < 0)
 		goto err;
 
@@ -1258,7 +1257,6 @@
 	ret = af9035_wr_reg_mask(d, 0xd8b7, 0x01, 0x01);
 	if (ret < 0)
 		goto err;
-
 	memset(&si2168_config, 0, sizeof(si2168_config));
 	si2168_config.i2c_adapter = &adapter;
 	si2168_config.fe = &adap->fe[0];
@@ -1266,9 +1264,8 @@
 
 	state->af9033_config[adap->id].fe = &adap->fe[0];
 	state->af9033_config[adap->id].ops = &state->ops;
-	ret = af9035_add_i2c_dev(d, "si2168",
-				 it930x_addresses_table[state->it930x_addresses].frontend_i2c_addr,
-				 &si2168_config, &d->i2c_adap);
+	ret = af9035_add_i2c_dev(d, "si2168", 0x67, &si2168_config,
+				&d->i2c_adap);
 	if (ret)
 		goto err;
 
@@ -1617,33 +1614,54 @@
 
 	dev_dbg(&intf->dev, "adap->id=%d\n", adap->id);
 
+	/* I2C master bus 2 clock speed 300k */
+	ret = af9035_wr_reg(d, 0x00f6a7, 0x07);
+	if (ret < 0)
+		goto err;
+
+	/* I2C master bus 1,3 clock speed 300k */
+	ret = af9035_wr_reg(d, 0x00f103, 0x07);
+	if (ret < 0)
+		goto err;
+
+	/* set gpio11 low */
+	ret = af9035_wr_reg_mask(d, 0xd8d4, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
+	ret = af9035_wr_reg_mask(d, 0xd8d5, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
+	ret = af9035_wr_reg_mask(d, 0xd8d3, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
+	/* Tuner enable using gpiot2_en, gpiot2_on and gpiot2_o (reset) */
+	ret = af9035_wr_reg_mask(d, 0xd8b8, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
+	ret = af9035_wr_reg_mask(d, 0xd8b9, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
+	ret = af9035_wr_reg_mask(d, 0xd8b7, 0x00, 0x01);
+	if (ret < 0)
+		goto err;
+
+	msleep(200);
+
+	ret = af9035_wr_reg_mask(d, 0xd8b7, 0x01, 0x01);
+	if (ret < 0)
+		goto err;
+
 	memset(&si2157_config, 0, sizeof(si2157_config));
 	si2157_config.fe = adap->fe[0];
+	si2157_config.if_port = 1;
+	ret = af9035_add_i2c_dev(d, "si2157", 0x63,
+			&si2157_config, state->i2c_adapter_demod);
 
-	/*
-	 * HACK: The Logilink VG0022A and TerraTec TC2 Stick have
-	 * a bug: when the si2157 firmware that came with the device
-	 * is replaced by a new one, the I2C transfers to the tuner
-	 * will return just 0xff.
-	 *
-	 * Probably, the vendor firmware has some patch specifically
-	 * designed for this device. So, we can't replace by the
-	 * generic firmware. The right solution would be to extract
-	 * the si2157 firmware from the original driver and ask the
-	 * driver to load the specifically designed firmware, but,
-	 * while we don't have that, the next best solution is to just
-	 * keep the original firmware at the device.
-	 */
-	if ((le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_DEXATEK &&
-	     le16_to_cpu(d->udev->descriptor.idProduct) == 0x0100) ||
-	    (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_TERRATEC &&
-	     le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_TERRATEC_CINERGY_TC2_STICK))
-		si2157_config.dont_load_firmware = true;
-
-	si2157_config.if_port = it930x_addresses_table[state->it930x_addresses].tuner_if_port;
-	ret = af9035_add_i2c_dev(d, "si2157",
-				 it930x_addresses_table[state->it930x_addresses].tuner_i2c_addr,
-				 &si2157_config, state->i2c_adapter_demod);
 	if (ret)
 		goto err;
 
@@ -1851,7 +1869,7 @@
 {
 	struct usb_interface *intf = d->intf;
 	int ret;
-	enum rc_proto proto;
+	enum rc_type proto;
 	u32 key;
 	u8 buf[4];
 	struct usb_req req = { CMD_IR_GET, 0, 0, NULL, 4, buf };
@@ -1866,17 +1884,17 @@
 		if ((buf[0] + buf[1]) == 0xff) {
 			/* NEC standard 16bit */
 			key = RC_SCANCODE_NEC(buf[0], buf[2]);
-			proto = RC_PROTO_NEC;
+			proto = RC_TYPE_NEC;
 		} else {
 			/* NEC extended 24bit */
 			key = RC_SCANCODE_NECX(buf[0] << 8 | buf[1], buf[2]);
-			proto = RC_PROTO_NECX;
+			proto = RC_TYPE_NECX;
 		}
 	} else {
 		/* NEC full code 32bit */
 		key = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |
 					buf[2] << 8  | buf[3]);
-		proto = RC_PROTO_NEC32;
+		proto = RC_TYPE_NEC32;
 	}
 
 	dev_dbg(&intf->dev, "%*ph\n", 4, buf);
@@ -1904,11 +1922,11 @@
 		switch (state->ir_type) {
 		case 0: /* NEC */
 		default:
-			rc->allowed_protos = RC_PROTO_BIT_NEC |
-					RC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32;
+			rc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX |
+								RC_BIT_NEC32;
 			break;
 		case 1: /* RC6 */
-			rc->allowed_protos = RC_PROTO_BIT_RC6_MCE;
+			rc->allowed_protos = RC_BIT_RC6_MCE;
 			break;
 		}
 
@@ -2131,8 +2149,6 @@
 	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_CTVDIGDUAL_V2,
 		&af9035_props, "Digital Dual TV Receiver CTVDIGDUAL_V2",
 							RC_MAP_IT913X_V1) },
-	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_T1,
-		&af9035_props, "TerraTec T1", RC_MAP_IT913X_V1) },
 	/* XXX: that same ID [0ccd:0099] is used by af9015 driver too */
 	{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x0099,
 		&af9035_props, "TerraTec Cinergy T Stick Dual RC (rev. 2)",
@@ -2149,12 +2165,10 @@
 	/* IT930x devices */
 	{ DVB_USB_DEVICE(USB_VID_ITETECH, USB_PID_ITETECH_IT9303,
 		&it930x_props, "ITE 9303 Generic", NULL) },
-	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_TD310,
-		&it930x_props, "AVerMedia TD310 DVB-T2", NULL) },
 	{ DVB_USB_DEVICE(USB_VID_DEXATEK, 0x0100,
 		&it930x_props, "Logilink VG0022A", NULL) },
-	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_TC2_STICK,
-		&it930x_props, "TerraTec Cinergy TC2 Stick", NULL) },
+    { DVB_USB_DEVICE(USB_VID_TERRATEC, 0x10b2,
+        &it930x_props, "TerraTec Cinergy TC2 Stick", NULL) },
 	{ }
 };
 MODULE_DEVICE_TABLE(usb, af9035_id_table);
